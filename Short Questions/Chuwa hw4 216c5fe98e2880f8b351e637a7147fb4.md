# Chuwa hw4

## Question 1

### Singleton

```java
public class SingletonDemo {

    // --- Eager Singleton ---
    static class EagerSingleton {
        private static final EagerSingleton instance = new EagerSingleton();

        private EagerSingleton() {
            System.out.println("EagerSingleton created");
        }

        public static EagerSingleton getInstance() {
            return instance;
        }

        public void showMessage() {
            System.out.println("Hello from EagerSingleton");
        }
    }

    // --- Lazy Singleton (Thread-safe using synchronized) ---
    static class LazySingleton {
        private static LazySingleton instance;

        private LazySingleton() {
            System.out.println("LazySingleton created");
        }

        public static synchronized LazySingleton getInstance() {
            if (instance == null) {
                instance = new LazySingleton();
            }
            return instance;
        }

        public void showMessage() {
            System.out.println("Hello from LazySingleton");
        }
    }

    // --- Main method to test both ---
    public static void main(String[] args) {
        System.out.println("=== Accessing EagerSingleton ===");
        EagerSingleton eager1 = EagerSingleton.getInstance();
        EagerSingleton eager2 = EagerSingleton.getInstance();
        eager1.showMessage();
        System.out.println("Eager same instance? " + (eager1 == eager2));

        System.out.println("\n=== Accessing LazySingleton ===");
        LazySingleton lazy1 = LazySingleton.getInstance();
        LazySingleton lazy2 = LazySingleton.getInstance();
        lazy1.showMessage();
        System.out.println("Lazy same instance? " + (lazy1 == lazy2));
    }
}

```

So for the eager one, our instance only instantiated as soon as class loaded, and since class loader is thread safe, we make sure thread safe.

For our lazy one, our instance only instantiated when getInstance called. We have synchronized keyword for that method to help us avoid race condition. And if we already instantiated that instance before, we will check the one we created before.

 

### Factory Pattern

```java
public class FactoryMethodDemo {

    // Product interface
    interface Shape {
        void draw();
    }

    // Concrete Products
    static class Circle implements Shape {
        public void draw() {
            System.out.println("Drawing a Circle");
        }
    }

    static class Rectangle implements Shape {
        public void draw() {
            System.out.println("Drawing a Rectangle");
        }
    }

    static class Square implements Shape {
        public void draw() {
            System.out.println("Drawing a Square");
        }
    }

    // Creator (Factory)
    abstract static class ShapeFactory {
        public abstract Shape createShape();
    }

    // Concrete Factories
    static class CircleFactory extends ShapeFactory {
        public Shape createShape() {
            return new Circle();
        }
    }

    static class RectangleFactory extends ShapeFactory {
        public Shape createShape() {
            return new Rectangle();
        }
    }

    static class SquareFactory extends ShapeFactory {
        public Shape createShape() {
            return new Square();
        }
    }

    // Main method (Client)
    public static void main(String[] args) {
        ShapeFactory circleFactory = new CircleFactory();
        Shape circle = circleFactory.createShape();
        circle.draw();

        ShapeFactory rectangleFactory = new RectangleFactory();
        Shape rectangle = rectangleFactory.createShape();
        rectangle.draw();

        ShapeFactory squareFactory = new SquareFactory();
        Shape square = squareFactory.createShape();
        square.draw();
    }
}

```

it will return Draw a Circle, Draw a rectangle and Draw a square

### Abstract Factory

```java
public class AbstractFactoryDemo {

    // Product interface
    interface Shape {
        void draw();
    }

    // 2D Shapes
    static class Circle implements Shape {
        public void draw() {
            System.out.println("Drawing a 2D Circle");
        }
    }

    static class Square implements Shape {
        public void draw() {
            System.out.println("Drawing a 2D Square");
        }
    }

    // 3D Shapes
    static class Sphere implements Shape {
        public void draw() {
            System.out.println("Drawing a 3D Sphere");
        }
    }

    static class Cube implements Shape {
        public void draw() {
            System.out.println("Drawing a 3D Cube");
        }
    }

    // Abstract Factory
    interface AbstractShapeFactory {
        Shape createShape(String type);
    }

    // Concrete Factory: 2D
    static class Shape2DFactory implements AbstractShapeFactory {
        public Shape createShape(String type) {
            switch (type.toLowerCase()) {
                case "circle":
                    return new Circle();
                case "square":
                    return new Square();
                default:
                    throw new IllegalArgumentException("Unknown 2D shape: " + type);
            }
        }
    }

    // Concrete Factory: 3D
    static class Shape3DFactory implements AbstractShapeFactory {
        public Shape createShape(String type) {
            switch (type.toLowerCase()) {
                case "sphere":
                    return new Sphere();
                case "cube":
                    return new Cube();
                default:
                    throw new IllegalArgumentException("Unknown 3D shape: " + type);
            }
        }
    }

    // Factory Producer
    static class FactoryProducer {
        public static AbstractShapeFactory getFactory(boolean is3D) {
            return is3D ? new Shape3DFactory() : new Shape2DFactory();
        }
    }

    // Main method (client)
    public static void main(String[] args) {
        // Get 2D factory
        AbstractShapeFactory shape2DFactory = FactoryProducer.getFactory(false);
        Shape circle = shape2DFactory.createShape("circle");
        circle.draw();

        Shape square = shape2DFactory.createShape("square");
        square.draw();

        // Get 3D factory
        AbstractShapeFactory shape3DFactory = FactoryProducer.getFactory(true);
        Shape sphere = shape3DFactory.createShape("sphere");
        sphere.draw();

        Shape cube = shape3DFactory.createShape("cube");
        cube.draw();
    }
}

```

So, as we can see the difference between abstract factory and factory is that we have factory producer, and with the help of that factory producer we can actually make a family of objects which are related. For example, we can use one concrete factory to make all 2D shapes and the other concrete factory to help us make all 3D shapes.

### Builder

```java
public class BuilderPatternDemo {

    // Product class
    static class House {
        private String walls;
        private String doors;
        private String roof;

        public void setWalls(String walls) { this.walls = walls; }
        public void setDoors(String doors) { this.doors = doors; }
        public void setRoof(String roof) { this.roof = roof; }

        public void showHouse() {
            System.out.println("House built with:");
            System.out.println("Walls: " + walls);
            System.out.println("Doors: " + doors);
            System.out.println("Roof: " + roof);
        }
    }

    // Builder interface
    interface HouseBuilder {
        void buildWalls(int size);
        void buildDoors(int size);
        void buildRoof(int size);
        House getHouse();
    }

    // Concrete Builder: Wooden
    static class WoodenHouseBuilder implements HouseBuilder {
        private House house = new House();

        public void buildWalls(int size) {
            house.setWalls("Wooden Walls of size " + size);
        }

        public void buildDoors(int size) {
            house.setDoors("Wooden Doors of size " + size);
        }

        public void buildRoof(int size) {
            house.setRoof("Wooden Roof of size " + size);
        }

        public House getHouse() {
            return house;
        }
    }

    // Concrete Builder: Stone
    static class StoneHouseBuilder implements HouseBuilder {
        private House house = new House();

        public void buildWalls(int size) {
            house.setWalls("Stone Walls of thickness " + size);
        }

        public void buildDoors(int size) {
            house.setDoors("Stone Doors of size " + size);
        }

        public void buildRoof(int size) {
            house.setRoof("Stone Roof of weight " + (size * 100) + "kg");
        }

        public House getHouse() {
            return house;
        }
    }

    // Director
    static class HouseDirector {
        private final HouseBuilder builder;

        public HouseDirector(HouseBuilder builder) {
            this.builder = builder;
        }

        public void constructSmallHouse() {
            builder.buildWalls(2);
            builder.buildDoors(1);
            builder.buildRoof(2);
        }

        public void constructBigHouse() {
            builder.buildWalls(10);
            builder.buildDoors(5);
            builder.buildRoof(8);
        }

        public House getHouse() {
            return builder.getHouse();
        }
    }

    // Main method (Client)
    public static void main(String[] args) {
        // Small Wooden House
        System.out.println("=== Small Wooden House ===");
        HouseBuilder woodenBuilder = new WoodenHouseBuilder();
        HouseDirector woodenDirector = new HouseDirector(woodenBuilder);
        woodenDirector.constructSmallHouse();
        woodenDirector.getHouse().showHouse();

        // Big Wooden House
        System.out.println("\n=== Big Wooden House ===");
        woodenBuilder = new WoodenHouseBuilder();
        woodenDirector = new HouseDirector(woodenBuilder);
        woodenDirector.constructBigHouse();
        woodenDirector.getHouse().showHouse();

        // Small Stone House
        System.out.println("\n=== Small Stone House ===");
        HouseBuilder stoneBuilder = new StoneHouseBuilder();
        HouseDirector stoneDirector = new HouseDirector(stoneBuilder);
        stoneDirector.constructSmallHouse();
        stoneDirector.getHouse().showHouse();

        // Big Stone House
        System.out.println("\n=== Big Stone House ===");
        stoneBuilder = new StoneHouseBuilder();
        stoneDirector = new HouseDirector(stoneBuilder);
        stoneDirector.constructBigHouse();
        stoneDirector.getHouse().showHouse();
    }
}

```

This is my builder, so we have two types of house, one is wooden the other one is stone. And we call our director to help use build houses. Also for director, we actually have different building parameters to help use build small or large houses.

## Question 2

```java
public class Q2_InterfaceDefaultStaticDemo {

    interface Vehicle {
        default void start() {
            System.out.println("Vehicle is starting...");
        }

        static void service() {
            System.out.println("Vehicle is being serviced...");
        }
    }

    static class Car implements Vehicle {
        // Inherits default method from Vehicle
    }

    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.start();         // Calls the default method
        Vehicle.service();     // Calls the static method from interface
    }
}

```

Default methods let an interface can have a default implementation of the method

So if the class Car inherits the default method, we don’t need to override and we can just use it.

static methods let us can use methods directly call interface name and use it.

## Question 3

```java
public class Q3_AnonymousClassDemo {

    abstract static class Animal {
        abstract void makeSound();
    }

    public static void main(String[] args) {
        Animal dog = new Animal() {
            @Override
            void makeSound() {
                System.out.println("Woof! I'm an anonymous dog.");
            }
        };

        dog.makeSound();
    }
}

```

As we can see, the abstract class supposed not to be instantiated, but when we use anonymous class. It’s like an inline implementation of a class. So it’s very convenient for us to just override one or two methods without create a separate named class.

## Question 4

```java
public class Q4_LambdaExpressionDemo {

    @FunctionalInterface
    interface Greeting {
        void sayHello(String name);
    }

    public static void main(String[] args) {
        Greeting greeting = (name) -> System.out.println("Hello, " + name + "!");
        greeting.sayHello("Alice");
    }
}

```

- A **lambda expression** is a concise way to implement a **functional interface** (an interface with only one abstract method).
- It improves readability and is often used in streams, event handling, or any place you need a simple behavior.
- Here, `(name) -> { ... }` replaces the need to write a whole class to implement `Greeting`.

## Question 5

See the code under coding folder