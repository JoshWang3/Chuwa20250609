# 06/14

1. Created Employee.java, Address.java, and [Department.java](http://Department.java) files
2. Created [Main.java](http://Main.java) and initiate two Employee instances `emp1`, `emp2` in Main.java. 
    
    Also created `insinspectObject` in Main.java. The objects are allocated in heap memory while the instances (`emp1`, `emp2`) are store on the stack. 
    
3. Create a static method `getCompanyName()` in [Employee.java](http://Employee.java). We don’t need create an object to call a static method: `Employee.getCompanyName()`. 
4. Based on the definition, the global variable is a filed with keywords `public static`. It means the variable can be accessed and modified without restriction in the package. 
    
    ```java
    class GlobalVariables {
    	public static int counter = 0;
    	public static void increment() {
        counter++;
    	}
    }
    ```
    
    ```java
    public class A {
        public void doSomething() {
            GlobalVariables.counter++;
        }
    }
    ```
    
    There are some reasons we don’t recommend to use global variables:
    
    1. It’s hard to track where and when to change when we try to debug. 
    2. It does not conform to encapsulation. Anyone can access the filed which makes the information unsafe and expose to the public. In java, these are expected to hide behind class boundaries. 
5. Immutable means once an object is created, its data/fields can’t be modified. As for `String`, it can’t be changed the value of a `String object`.  We need to create a new object if we’d like to obtain a changed value. 
    
    ```java
    String s1 = "Hello";
    String original = s1;
    
    s1 = s1 + " world";
    
    System.out.println("original = " + original);  // "hello"
    System.out.println("s1 = " + s1);              // "hello world"
    ```
    
    Like the code example above, `original` is assigned by `s1` . Even we tried to change the value through `s1 = s1 + " world"` , `original` still keeps the old value, which proves String is immutable.  
    
6. The keyword `final` means can’t be changed after assignment. It will be applied in variable, method, and class. 
    
    Usually we use it for configuration values and invariants. 
    
    ```java
    public class A {
    	public static void main (String[] args) {
    		final int a = 10;
    		// a = 20; Will show error 
    	}
    }
    ```
    
    If we use it in method, we can’t override it in subclass. 
    
    ```java
    public class A {
    	public final void printInfo() {
    		System.out.println("Can't be overridden");
    	}
    }
    
    public class B extends A {
    	//public void printInfo(); Will show error
    }
    ```
    
    If we use it in class, we can’t extend it in other classes. We usually use it for utility classes. 
    
    ```java
    public class A {
    	public final void printInfo() {
    		System.out.println("Can't be overridden");
    	}
    }
    // public class B extends A; Will show error
    ```
    
7. Java only passes a copy of the variable instead of the variable itself. It applies both primitive types and object references. 
    
    ```java
    public class Demo {
    	public static void addTen(int x) {
    		x = x + 10;
    	}
    	
    	public static void main(String[] args) {
    		int a = 5;
    		addTen(a);
    		System.out.println("a = " + a); // output: a = 5
    	}
    }
    ```
    
    ```java
    class A {
    	public int value = 10;
    }
    
    public class Demo {
    	public static void changeValue(A a) {
    		a.value = 20; // modifies the object
    		a = new A();
    		a.value = 90;
    	}
    	
    	public static void main(String[] args) {
    		A a = new A();
    		changeValue(a);
    		System.out.println("a = " + a.value); // output: a = 20
    	}
    }
    ```
    
    When we modify the object’s fields, Java actually create a copy of the object and assign with the new value instead of the actual/original object. 
    
8. Method overloading means multiple methods with the same name but with different (number / type of) parameters within the same class.
    
    ```java
    public class A {
    	// Overload with different parameters
    	public double add(double a, double b) {
    		return a + b;
      }
      public double add(int a, double b) {
        return a + b;
      }
    }
    ```
    
    Method signature includes (1) method name, (2) number, type, and order of parameters.